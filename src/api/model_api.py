from fastapi import FastAPI, File, UploadFile
from src.api.predictor import analyze_file_n_predict
from src.api.cache import Cache
from src.api.database import Database
from src.api.model_queue import ModelQueue
from src.utilities.file import get_project_root_directory
import pefile
from hashlib import md5
from pathlib import Path

malware_detector = FastAPI()
cache = Cache()
database = Database()
queue = ModelQueue()


@malware_detector.get('/')
async def root():
    return {'intro': 'This is a malware detector application.'}


def validate_pe_sample(file_content: bytes) -> bool:
    # Check whether a sample is a PE32 sample or not
    try:
        pe_info = pefile.PE(data=file_content)
        if pe_info.OPTIONAL_HEADER.Magic != 267:
            return False
        return True
    except pefile.PEFormatError:
        return False


def get_md5_hash_value(file_content: bytes):
    md5_getter = md5()
    md5_getter.update(file_content)
    return md5_getter.hexdigest()


@malware_detector.get('/predict/file/')
async def show_all_predictions():
    return database.load_all_prediction_results()


def get_found_cache_message(cache_output: dict) -> dict:
    # Create found in cache message
    try:
        file_id = cache_output['md5']
        found_cache_message = 'File request found in cache.'
        full_message = {
            'msg': found_cache_message,
            'file id': file_id
        }
        return full_message
    # File ID cannot be retrieved means the file is invalid
    # In this case, return whole cache output as message
    except KeyError:
        return cache_output


def get_found_db_message(error_output: dict = None, predicted_output: dict = None) -> dict:
    # Return whole error output if the file is invalid
    if error_output is not None:
        return error_output
    # Otherwise, create found in database message, and return it
    file_id = predicted_output['md5']
    found_db_message = 'File request found in database.'
    full_message = {
        'msg': found_db_message,
        'file id': file_id
    }
    return full_message


def get_file_still_processing_message(file_id):
    file_still_processing_message = 'Sorry, your file is still processing. Please wait for a little bit more.'
    full_message = {
        'msg': file_still_processing_message,
        'file id': file_id
    }
    return full_message


def get_error_message(file_id):
    error_msg = {'msg': 'Sorry, a PE32 file is expected, but this file is not a PE32 file.'}
    cache.write_to_cache(file_id, error_msg)
    database.save_new_error_file(file_id, error_msg)
    return error_msg


def create_new_file_path(file_name):
    # Uploaded files will be stored in /data/external folder
    file_location = get_project_root_directory() / Path('data/external')
    file_path = file_location / Path(file_name)
    return str(file_path)


def save_file(file_path, file_content):
    with open(file_path, 'wb') as file_save:
        file_save.write(file_content)
        file_save.close()


def get_successful_enqueued_message(file_id):
    successful_enqueued_message = 'Your file is successfully uploaded and enqueued. Please wait for a bit.'
    full_message = {
        'msg': successful_enqueued_message,
        'file id': file_id
    }
    return full_message


@malware_detector.post('/predict/file/', status_code=202)
async def upload_file(file: UploadFile = File(...)):
    # Get file name, content & file ID (MD5)
    file_name = file.filename
    file_content = file.file.read()
    file_id = get_md5_hash_value(file_content)
    # Check exist in cache
    cache_output = cache.read_from_cache(file_id)
    is_exist_cache = cache_output is not None
    if is_exist_cache:
        return get_found_cache_message(cache_output)
    # Check exist in database, for both error and predicted
    error_db_output = database.load_error_message(file_id)
    predicted_db_output = database.load_prediction(file_id)
    is_exist_db = (error_db_output is not None) or (predicted_db_output is not None)
    if is_exist_db:
        return get_found_db_message(error_db_output, predicted_db_output)
    # Check if the status of the file is "pending" or not
    status = database.load_status(file_id)
    is_pending = status == 'pending'
    if is_pending:
        return get_file_still_processing_message(file_id)
    # Validate the sample: show error message if the sample file is not PE32 file, cache and save to db
    if not validate_pe_sample(file_content):
        return get_error_message(file_id)
    # Save file
    file_path = create_new_file_path(file_name)
    save_file(file_path, file_content)
    # Initiate status (set status to "pending")
    database.create_new_status(file_id, file_name, file_path, status='pending')
    # Enqueue
    queue.enqueue(analyze_file_n_predict, file_id)
    # Return file enqueued message
    return get_successful_enqueued_message(file_id)


def get_file_id_invalid_message():
    file_id_invalid_message = {
        'msg': 'Sorry, your file ID is invalid. Please upload your file first.'
    }
    return file_id_invalid_message


@malware_detector.get('/predict/file/{file_id}')
def get_prediction_result(file_id: str):
    # Check status of the file corresponding to the ID
    status = database.load_status(file_id)
    # Check if the file is in error file database (if status is None)
    is_exist_error_db = database.load_error_message(file_id) is not None
    if status is None and is_exist_error_db:
        return database.load_error_message(file_id)
    # Return file ID invalid message if not exist in error file database either
    elif status is None and not is_exist_error_db:
        return get_file_id_invalid_message()
    # Return error message for "failed" files
    if status == 'failed':
        return database.load_error_message(file_id)
    # Return file is still processing message for "pending" files
    elif status == 'pending':
        return get_file_still_processing_message(file_id)
    # Otherwise: get prediction result
    else:
        return database.load_prediction(file_id)
