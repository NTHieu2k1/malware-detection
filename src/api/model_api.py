from fastapi import FastAPI, File, UploadFile
from src.api.predictor import analyze_file_n_predict
from src.api.cache import Cache
from src.api.database import Database
from src.api.model_queue import ModelQueue
from src.utilities.file import get_project_root_directory
import pefile
from hashlib import md5
from pathlib import Path

malware_detector = FastAPI()
cache = Cache()
database = Database()
queue = ModelQueue()

# TODO: Put inner file save location into config file
uploaded_file_location = get_project_root_directory() / Path('data/external')


@malware_detector.get('/')
async def root():
    return {'intro': 'This is a malware detector application.'}


def validate_pe_sample(file_content: bytes) -> bool:
    # Check whether a sample is a PE32 sample or not
    try:
        pe_info = pefile.PE(data=file_content)
        if pe_info.OPTIONAL_HEADER.Magic != 267:
            return False
        return True
    except pefile.PEFormatError:
        return False


def get_md5_hash_value(file_content: bytes):
    md5_getter = md5()
    md5_getter.update(file_content)
    return md5_getter.hexdigest()


@malware_detector.get('/predict/file/')
async def show_all_predictions():
    return database.load_all_prediction_results()


def get_found_cache_message(cache_output: dict) -> dict:
    # Create found in cache message
    try:
        file_id = cache_output['md5']
        found_cache_message = 'File request found in cache.'
        full_message = {
            'msg': found_cache_message,
            'file id': file_id
        }
        return full_message
    # File ID cannot be retrieved means the file is invalid
    # In this case, return whole cache output as message
    except KeyError:
        return cache_output


def get_found_db_message(file_id, error_output: dict = None) -> dict:
    # Return whole error output if the file is invalid
    if error_output is not None and error_output != {}:
        return error_output
    # Otherwise, create found in database message, and return it
    found_db_message = 'File request found in database.'
    full_message = {
        'msg': found_db_message,
        'file id': file_id
    }
    return full_message


def get_file_still_processing_message(file_id):
    file_still_processing_message = 'Sorry, your file is still processing. Please wait for a little bit more.'
    full_message = {
        'msg': file_still_processing_message,
        'file id': file_id
    }
    return full_message


def get_error_message(file_id):
    error_msg = {'msg': 'Sorry, a PE32 file is expected, but this file is not a PE32 file.'}
    cache.save_error_messages_to_cache(file_id, error_msg)
    database.add_error_message(file_id, error_msg)
    return error_msg


def create_new_file_path(file_name):
    # Uploaded files will be stored in /data/external folder
    file_location = get_project_root_directory() / Path('data/external')
    file_path = file_location / Path(file_name)
    return str(file_path)


def save_file(file_path, file_content):
    with open(file_path, 'wb') as file_save:
        file_save.write(file_content)
        file_save.close()


def get_successful_enqueued_message(file_id):
    successful_enqueued_message = 'Your file is successfully uploaded and enqueued. Please wait for a bit.'
    full_message = {
        'msg': successful_enqueued_message,
        'file id': file_id
    }
    return full_message


@malware_detector.post('/predict/file/', status_code=202)
async def upload_file(file: UploadFile = File(...)):
    # Get file name, content & file ID (MD5)
    file_name = file.filename
    file_content = file.file.read()
    file_id = get_md5_hash_value(file_content)
    # Check exist in cache
    cache_output = cache.read_from_cache(file_id)
    is_exist_cache = cache_output is not None
    if is_exist_cache:
        return get_found_cache_message(cache_output)
    # Check result exist in database
    error_msg = database.load_error_message(file_id)
    is_exist_db = database.is_file_exist(file_id)
    if is_exist_db:
        return get_found_db_message(file_id)
    # Check if the status of the file is "pending" or not (if no results found)
    status = database.load_status(file_id)
    is_pending = status == 'pending'
    if is_pending:
        return get_file_still_processing_message(file_id)
    # Create new file information
    database.create_new_file_info(file_id, file_name, status='uploaded')
    # Validate the sample: show error message if the sample file is not PE32 file,
    # set "failed" status, cache and save to db
    if not validate_pe_sample(file_content):
        database.update_status(file_id, new_status='failed')
        return get_error_message(file_id)
    # Save file
    file_path = uploaded_file_location / Path(file_name)
    save_file(file_path, file_content)
    # Change status to "pending"
    database.update_status(file_id, new_status='pending')
    # Enqueue
    queue.enqueue(analyze_file_n_predict, file_id)
    # Return file enqueued message
    return get_successful_enqueued_message(file_id)


def get_file_id_invalid_message():
    file_id_invalid_message = {
        'msg': 'Sorry, your file ID is invalid. Please upload your file first.'
    }
    return file_id_invalid_message


def get_prediction_results_from_db(file_id):
    file_name = database.load_file_name(file_id)
    predictions = database.load_prediction(file_id)
    prediction_result = {
        'file': file_name,
        'md5': file_id,
        'predictions': predictions
    }
    return prediction_result


@malware_detector.get('/predict/file/{file_id}')
def get_prediction_result(file_id: str):
    # Check if file's result exist in cache
    cache_result = cache.read_from_cache(file_id)
    # Return cache result if exist
    if cache_result is not None:
        return cache_result
    # Check status of the file corresponding to the ID
    status = database.load_status(file_id)
    # Return file ID invalid message if status is None
    if status is None:
        return get_file_id_invalid_message()
    # Return error message for "failed" files
    if status == 'failed':
        return database.load_error_message(file_id)
    # Return file is still processing message for "pending" files
    elif status == 'pending':
        return get_file_still_processing_message(file_id)
    # Otherwise: get prediction result
    else:
        return get_prediction_results_from_db(file_id)
