import pefile
from pefile import PE
from pathlib import Path
from src.data.crawlers import get_project_root_directory
from abc import ABC, abstractmethod
import pandas as pd


class Explorer(ABC):
    def __init__(self):
        pass

    @abstractmethod
    def get_dos_header(self, pe_file):
        pass

    @abstractmethod
    def get_signature(self, pe_file):
        pass

    @abstractmethod
    def get_file_header(self, pe_file):
        pass

    @abstractmethod
    def get_optional_header(self, pe_file):
        pass

    @abstractmethod
    def get_all_pe_information(self, pe_file_path):
        pass


class BaseExplorer(Explorer):
    def __init__(self):
        self.inner_csv_location = 'data/interim/extracted_malware_dataset.csv'
        self._csv_location = ''

    @property
    def csv_location(self):
        return self._csv_location

    @csv_location.setter
    def csv_location(self, updated_location):
        self._csv_location = updated_location

    def set_csv_location(self):
        self.csv_location = get_project_root_directory() / Path(self.inner_csv_location)

    def get_dos_header(self, pe_file):
        # Extract all fields in DOS header, and store them in a dictionary
        dos_header = dict()
        dos_header['e_magic'] = [pe_file.DOS_HEADER.e_magic]
        dos_header['e_cblp'] = [pe_file.DOS_HEADER.e_cblp]
        dos_header['e_cp'] = [pe_file.DOS_HEADER.e_cp]
        dos_header['e_crlc'] = [pe_file.DOS_HEADER.e_crlc]
        dos_header['e_cparhdr'] = [pe_file.DOS_HEADER.e_cparhdr]
        dos_header['e_minalloc'] = [pe_file.DOS_HEADER.e_minalloc]
        dos_header['e_maxalloc'] = [pe_file.DOS_HEADER.e_maxalloc]
        dos_header['e_ss'] = [pe_file.DOS_HEADER.e_ss]
        dos_header['e_sp'] = [pe_file.DOS_HEADER.e_sp]
        dos_header['e_csum'] = [pe_file.DOS_HEADER.e_csum]
        dos_header['e_ip'] = [pe_file.DOS_HEADER.e_ip]
        dos_header['e_cs'] = [pe_file.DOS_HEADER.e_cs]
        dos_header['e_lfarlc'] = [pe_file.DOS_HEADER.e_lfarlc]
        dos_header['e_ovno'] = [pe_file.DOS_HEADER.e_ovno]
        dos_header['e_oemid'] = [pe_file.DOS_HEADER.e_oemid]
        dos_header['e_oeminfo'] = [pe_file.DOS_HEADER.e_oeminfo]
        dos_header['e_lfanew'] = [pe_file.DOS_HEADER.e_lfanew]
        return dos_header

    def get_signature(self, pe_file):
        return pe_file.NT_HEADERS.Signature

    def get_file_header(self, pe_file):
        # Extract all fields in file header, and store them in a dictionary
        file_header = dict()
        file_header['Machine'] = [pe_file.FILE_HEADER.Machine]
        file_header['NumberOfSections'] = [pe_file.FILE_HEADER.NumberOfSections]
        file_header['TimeDateStamp'] = [pe_file.FILE_HEADER.TimeDateStamp]
        file_header['PointerToSymbolTable'] = [pe_file.FILE_HEADER.PointerToSymbolTable]
        file_header['NumberOfSymbols'] = [pe_file.FILE_HEADER.NumberOfSymbols]
        file_header['SizeOfOptionalHeader'] = [pe_file.FILE_HEADER.SizeOfOptionalHeader]
        file_header['Characteristics'] = [pe_file.FILE_HEADER.Characteristics]
        return file_header

    def get_optional_header(self, pe_file):
        # Extract all fields in optional header, and store them in a dictionary
        optional_header = dict()
        optional_header['Magic'] = [pe_file.OPTIONAL_HEADER.Magic]
        optional_header['MajorLinkerVersion'] = [pe_file.OPTIONAL_HEADER.MajorLinkerVersion]
        optional_header['MinorLinkerVersion'] = [pe_file.OPTIONAL_HEADER.MinorLinkerVersion]
        optional_header['SizeOfCode'] = [pe_file.OPTIONAL_HEADER.SizeOfCode]
        optional_header['SizeOfInitializedData'] = [pe_file.OPTIONAL_HEADER.SizeOfInitializedData]
        optional_header['SizeOfUninitializedData'] = [pe_file.OPTIONAL_HEADER.SizeOfUninitializedData]
        optional_header['AddressOfEntryPoint'] = [pe_file.OPTIONAL_HEADER.AddressOfEntryPoint]
        optional_header['BaseOfCode'] = [pe_file.OPTIONAL_HEADER.BaseOfCode]
        optional_header['BaseOfData'] = [pe_file.OPTIONAL_HEADER.BaseOfData]
        optional_header['ImageBase'] = [pe_file.OPTIONAL_HEADER.ImageBase]
        optional_header['SectionAlignment'] = [pe_file.OPTIONAL_HEADER.SectionAlignment]
        optional_header['FileAlignment'] = [pe_file.OPTIONAL_HEADER.FileAlignment]
        optional_header['MajorOSVersion'] = [pe_file.OPTIONAL_HEADER.MajorOperatingSystemVersion]
        optional_header['MinorOSVersion'] = [pe_file.OPTIONAL_HEADER.MinorOperatingSystemVersion]
        optional_header['MajorImageVersion'] = [pe_file.OPTIONAL_HEADER.MajorImageVersion]
        optional_header['MinorImageVersion'] = [pe_file.OPTIONAL_HEADER.MinorImageVersion]
        optional_header['MajorSubsystemVersion'] = [pe_file.OPTIONAL_HEADER.MajorSubsystemVersion]
        optional_header['MinorSubsystemVersion'] = [pe_file.OPTIONAL_HEADER.MinorSubsystemVersion]
        optional_header['SizeOfImage'] = [pe_file.OPTIONAL_HEADER.SizeOfImage]
        optional_header['SizeOfHeaders'] = [pe_file.OPTIONAL_HEADER.SizeOfHeaders]
        optional_header['CheckSum'] = [pe_file.OPTIONAL_HEADER.CheckSum]
        optional_header['Subsystem'] = [pe_file.OPTIONAL_HEADER.Subsystem]
        optional_header['DllCharacteristics'] = [pe_file.OPTIONAL_HEADER.DllCharacteristics]
        optional_header['SizeOfStackReserve'] = [pe_file.OPTIONAL_HEADER.SizeOfStackReserve]
        optional_header['SizeOfStackCommit'] = [pe_file.OPTIONAL_HEADER.SizeOfStackCommit]
        optional_header['SizeOfHeapReserve'] = [pe_file.OPTIONAL_HEADER.SizeOfHeapReserve]
        optional_header['SizeOfHeapCommit'] = [pe_file.OPTIONAL_HEADER.SizeOfHeapCommit]
        optional_header['LoaderFlags'] = [pe_file.OPTIONAL_HEADER.LoaderFlags]
        optional_header['NumberOfRvaAndSizes'] = [pe_file.OPTIONAL_HEADER.NumberOfRvaAndSizes]
        return optional_header

    def get_all_pe_information(self, pe_file_path):
        # Load the PE file
        pe_file = PE(pe_file_path)
        # Create a dictionary to store all headers of the PE file
        pe_info = dict()
        # Extract all information about PE file
        pe_info.update(self.get_dos_header(pe_file))
        pe_info.update({'Signature': [self.get_signature(pe_file)]})
        pe_info.update(self.get_file_header(pe_file))
        pe_info.update(self.get_optional_header(pe_file))
        return pe_info


class BenignExplorer(BaseExplorer):
    def __init__(self):
        super().__init__()
        self.inner_raw_benign = 'data/raw/benign'
        self._raw_benign_directory = ''

    @property
    def raw_benign_directory(self):
        return self._raw_benign_directory

    @raw_benign_directory.setter
    def raw_benign_directory(self, new_raw_directory):
        self._raw_benign_directory = new_raw_directory

    def set_raw_benign_directory(self):
        self.raw_benign_directory = get_project_root_directory()/Path(self.inner_raw_benign)

    def benign_labelling(self, pe_info: dict):
        label = {'Class': 'benign'}
        pe_info.update(label)

    def export_to_csv(self, sample_index: int = 0):
        # Set raw benign directory, as well as csv location
        self.set_raw_benign_directory()
        self.set_csv_location()
        # Get all benign sample paths
        all_benign_paths = list(self.raw_benign_directory.glob('**/*'))[20:]
        number_of_samples = len(all_benign_paths)
        for index in range(sample_index, number_of_samples):
            try:
                # Retrieve all PE data of the sample, then label it
                try:
                    pe_info = self.get_all_pe_information(all_benign_paths[index])
                except pefile.PEFormatError:    # Skip parsing empty sample
                    continue
                except AttributeError:    # Skip parsing fragment sample
                    continue
                self.benign_labelling(pe_info)
                # Convert the labelled information into a Pandas Dataframe
                sample_dataframe = pd.DataFrame.from_dict(pe_info)
                # If this is the first sample, write the dataframe into a new csv file
                if index == 0:
                    sample_dataframe.to_csv(self.csv_location, mode='w', index=False, header=True)
                # Otherwise, append the dataframe in an existing csv file (no adding header)
                else:
                    sample_dataframe.to_csv(self.csv_location, mode='a', index=False, header=False)
            except:    # Print index checkpoint when stopped
                print('Exporting aborted at index ' + str(index) + '.')
                break


class MalwareExplorer(BaseExplorer):
    def __init__(self):
        super().__init__()
        self.inner_raw_malware = 'data/raw/malware'
        self._raw_malware_directory = ''
        self.inner_csv_location_1 = 'data/interim/extracted_malware_dataset_1.csv'
        self.csv_location_1 = ''

    @property
    def raw_malware_directory(self):
        return self._raw_malware_directory

    @raw_malware_directory.setter
    def raw_malware_directory(self, updated_malware_directory):
        self._raw_malware_directory = updated_malware_directory

    def set_raw_malware_directory(self):
        self.raw_malware_directory = get_project_root_directory() / Path(self.inner_raw_malware)

    def set_csv_location(self):
        self.csv_location_1 = get_project_root_directory() / Path(self.inner_csv_location_1)

    def malware_labelling(self, pe_info: dict):
        label = {'Class': 'malware'}
        pe_info.update(label)

    def export_to_csv(self, sample_index: int = 0):
        # Set raw malware directory, as well as csv location
        self.set_raw_malware_directory()
        self.set_csv_location()
        # Get all malware sample paths
        all_malware_paths = list(self.raw_malware_directory.glob('*'))
        number_of_samples = len(all_malware_paths)
        for index in range(sample_index, number_of_samples):
            try:
                # Retrieve all PE data of the sample, then label it
                try:
                    pe_info = self.get_all_pe_information(all_malware_paths[index])
                except pefile.PEFormatError:    # Skip parsing empty sample
                    continue
                except AttributeError:    # Skip parsing fragment sample
                    continue
                self.malware_labelling(pe_info)
                # Convert the labelled information into a Pandas Dataframe
                sample_dataframe = pd.DataFrame.from_dict(pe_info)
                # If this is the first sample, write the dataframe into a new csv file
                if index == 0:
                    sample_dataframe.to_csv(self.csv_location_1, mode='w', index=False, header=True)
                # Otherwise, append the dataframe in an existing csv file (no adding header)
                else:
                    sample_dataframe.to_csv(self.csv_location_1, mode='a', index=False, header=False)
            except Exception as e:    # Print index checkpoint when stopped
                print('Exporting aborted at index ' + str(index) + '.')
                break
