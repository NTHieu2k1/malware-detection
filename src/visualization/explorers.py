from pefile import PE
from pathlib import Path
from src.utilities.file import get_project_root_directory
from abc import ABC, abstractmethod
import pandas as pd
import numpy as np
import os


class Explorer(ABC):
    def __init__(self):
        pass

    @abstractmethod
    def get_dos_header(self, pe_file):
        pass

    @abstractmethod
    def get_signature(self, pe_file):
        pass

    @abstractmethod
    def get_file_header(self, pe_file):
        pass

    @abstractmethod
    def get_optional_header(self, pe_file):
        pass

    @abstractmethod
    def get_all_pe_information(self, pe_file_path):
        pass


class SampleExplorer(Explorer):
    def __init__(self):
        self.inner_csv_location = 'data/interim/extracted_malware_dataset.csv'
        self._csv_location = ''

    @property
    def csv_location(self):
        return self._csv_location

    @csv_location.setter
    def csv_location(self, updated_location):
        self._csv_location = updated_location

    def set_csv_location(self):
        self.csv_location = get_project_root_directory() / Path(self.inner_csv_location)

    def get_dos_header(self, pe_file):
        # Extract all fields in DOS header, and store them in a dictionary
        # If any error occurred, insert NaN values instead
        dos_header = dict()
        try:
            dos_header['e_magic'] = [pe_file.DOS_HEADER.e_magic]
        except:
            dos_header['e_magic'] = [np.NaN]
        try:
            dos_header['e_cblp'] = [pe_file.DOS_HEADER.e_cblp]
        except:
            dos_header['e_cblp'] = [np.NaN]
        try:
            dos_header['e_cp'] = [pe_file.DOS_HEADER.e_cp]
        except:
            dos_header['e_cp'] = [np.NaN]
        try:
            dos_header['e_crlc'] = [pe_file.DOS_HEADER.e_crlc]
        except:
            dos_header['e_crlc'] = [np.NaN]
        try:
            dos_header['e_cparhdr'] = [pe_file.DOS_HEADER.e_cparhdr]
        except:
            dos_header['e_cparhdr'] = [np.NaN]
        try:
            dos_header['e_minalloc'] = [pe_file.DOS_HEADER.e_minalloc]
        except:
            dos_header['e_minalloc'] = [np.NaN]
        try:
            dos_header['e_maxalloc'] = [pe_file.DOS_HEADER.e_maxalloc]
        except:
            dos_header['e_maxalloc'] = [np.NaN]
        try:
            dos_header['e_ss'] = [pe_file.DOS_HEADER.e_ss]
        except:
            dos_header['e_ss'] = [np.NaN]
        try:
            dos_header['e_sp'] = [pe_file.DOS_HEADER.e_sp]
        except:
            dos_header['e_sp'] = [np.NaN]
        try:
            dos_header['e_csum'] = [pe_file.DOS_HEADER.e_csum]
        except:
            dos_header['e_csum'] = [np.NaN]
        try:
            dos_header['e_ip'] = [pe_file.DOS_HEADER.e_ip]
        except:
            dos_header['e_ip'] = [np.NaN]
        try:
            dos_header['e_cs'] = [pe_file.DOS_HEADER.e_cs]
        except:
            dos_header['e_cs'] = [np.NaN]
        try:
            dos_header['e_lfarlc'] = [pe_file.DOS_HEADER.e_lfarlc]
        except:
            dos_header['e_lfarlc'] = [np.NaN]
        try:
            dos_header['e_ovno'] = [pe_file.DOS_HEADER.e_ovno]
        except:
            dos_header['e_ovno'] = [np.NaN]
        try:
            dos_header['e_oemid'] = [pe_file.DOS_HEADER.e_oemid]
        except:
            dos_header['e_oemid'] = [np.NaN]
        try:
            dos_header['e_oeminfo'] = [pe_file.DOS_HEADER.e_oeminfo]
        except:
            dos_header['e_oeminfo'] = [np.NaN]
        try:
            dos_header['e_lfanew'] = [pe_file.DOS_HEADER.e_lfanew]
        except:
            dos_header['e_lfanew'] = [np.NaN]
        return dos_header

    def get_signature(self, pe_file):
        try:
            return pe_file.NT_HEADERS.Signature
        except:
            return np.NaN

    def get_file_header(self, pe_file):
        # Extract all fields in file header, and store them in a dictionary
        # If any error occurred, insert NaN values instead
        file_header = dict()
        try:
            file_header['Machine'] = [pe_file.FILE_HEADER.Machine]
        except:
            file_header['Machine'] = [np.NaN]
        try:
            file_header['NumberOfSections'] = [pe_file.FILE_HEADER.NumberOfSections]
        except:
            file_header['NumberOfSections'] = [np.NaN]
        try:
            file_header['TimeDateStamp'] = [pe_file.FILE_HEADER.TimeDateStamp]
        except:
            file_header['TimeDateStamp'] = [np.NaN]
        try:
            file_header['PointerToSymbolTable'] = [pe_file.FILE_HEADER.PointerToSymbolTable]
        except:
            file_header['PointerToSymbolTable'] = [np.NaN]
        try:
            file_header['NumberOfSymbols'] = [pe_file.FILE_HEADER.NumberOfSymbols]
        except:
            file_header['NumberOfSymbols'] = [np.NaN]
        try:
            file_header['SizeOfOptionalHeader'] = [pe_file.FILE_HEADER.SizeOfOptionalHeader]
        except:
            file_header['SizeOfOptionalHeader'] = [np.NaN]
        try:
            file_header['Characteristics'] = [pe_file.FILE_HEADER.Characteristics]
        except:
            file_header['Characteristics'] = [np.NaN]
        return file_header

    def get_optional_header(self, pe_file):
        # Extract all fields in optional header, and store them in a dictionary
        # If any error occurred, insert NaN values instead
        optional_header = dict()
        try:
            optional_header['Magic'] = [pe_file.OPTIONAL_HEADER.Magic]
        except:
            optional_header['Magic'] = [np.NaN]
        try:
            optional_header['MajorLinkerVersion'] = [pe_file.OPTIONAL_HEADER.MajorLinkerVersion]
        except:
            optional_header['MajorLinkerVersion'] = [np.NaN]
        try:
            optional_header['MinorLinkerVersion'] = [pe_file.OPTIONAL_HEADER.MinorLinkerVersion]
        except:
            optional_header['MinorLinkerVersion'] = [np.NaN]
        try:
            optional_header['SizeOfCode'] = [pe_file.OPTIONAL_HEADER.SizeOfCode]
        except:
            optional_header['SizeOfCode'] = [np.NaN]
        try:
            optional_header['SizeOfInitializedData'] = [pe_file.OPTIONAL_HEADER.SizeOfInitializedData]
        except:
            optional_header['SizeOfInitializedData'] = [np.NaN]
        try:
            optional_header['SizeOfUninitializedData'] = [pe_file.OPTIONAL_HEADER.SizeOfUninitializedData]
        except:
            optional_header['SizeOfUninitializedData'] = [np.NaN]
        try:
            optional_header['AddressOfEntryPoint'] = [pe_file.OPTIONAL_HEADER.AddressOfEntryPoint]
        except:
            optional_header['AddressOfEntryPoint'] = [np.NaN]
        try:
            optional_header['BaseOfCode'] = [pe_file.OPTIONAL_HEADER.BaseOfCode]
        except:
            optional_header['BaseOfCode'] = [np.NaN]
        try:
            optional_header['BaseOfData'] = [pe_file.OPTIONAL_HEADER.BaseOfData]
        except:
            optional_header['BaseOfData'] = [np.NaN]
        try:
            optional_header['ImageBase'] = [pe_file.OPTIONAL_HEADER.ImageBase]
        except:
            optional_header['ImageBase'] = [np.NaN]
        try:
            optional_header['SectionAlignment'] = [pe_file.OPTIONAL_HEADER.SectionAlignment]
        except:
            optional_header['SectionAlignment'] = [np.NaN]
        try:
            optional_header['FileAlignment'] = [pe_file.OPTIONAL_HEADER.FileAlignment]
        except:
            optional_header['FileAlignment'] = [np.NaN]
        try:
            optional_header['MajorOSVersion'] = [pe_file.OPTIONAL_HEADER.MajorOperatingSystemVersion]
        except:
            optional_header['MajorOSVersion'] = [np.NaN]
        try:
            optional_header['MinorOSVersion'] = [pe_file.OPTIONAL_HEADER.MinorOperatingSystemVersion]
        except:
            optional_header['MinorOSVersion'] = [np.NaN]
        try:
            optional_header['MajorImageVersion'] = [pe_file.OPTIONAL_HEADER.MajorImageVersion]
        except:
            optional_header['MajorImageVersion'] = [np.NaN]
        try:
            optional_header['MinorImageVersion'] = [pe_file.OPTIONAL_HEADER.MinorImageVersion]
        except:
            optional_header['MinorImageVersion'] = [np.NaN]
        try:
            optional_header['MajorSubsystemVersion'] = [pe_file.OPTIONAL_HEADER.MajorSubsystemVersion]
        except:
            optional_header['MajorSubsystemVersion'] = [np.NaN]
        try:
            optional_header['MinorSubsystemVersion'] = [pe_file.OPTIONAL_HEADER.MinorSubsystemVersion]
        except:
            optional_header['MinorSubsystemVersion'] = [np.NaN]
        try:
            optional_header['SizeOfImage'] = [pe_file.OPTIONAL_HEADER.SizeOfImage]
        except:
            optional_header['SizeOfImage'] = [np.NaN]
        try:
            optional_header['SizeOfHeaders'] = [pe_file.OPTIONAL_HEADER.SizeOfHeaders]
        except:
            optional_header['SizeOfHeaders'] = [np.NaN]
        try:
            optional_header['CheckSum'] = [pe_file.OPTIONAL_HEADER.CheckSum]
        except:
            optional_header['CheckSum'] = [np.NaN]
        try:
            optional_header['Subsystem'] = [pe_file.OPTIONAL_HEADER.Subsystem]
        except:
            optional_header['Subsystem'] = [np.NaN]
        try:
            optional_header['DllCharacteristics'] = [pe_file.OPTIONAL_HEADER.DllCharacteristics]
        except:
            optional_header['DllCharacteristics'] = [np.NaN]
        try:
            optional_header['SizeOfStackReserve'] = [pe_file.OPTIONAL_HEADER.SizeOfStackReserve]
        except:
            optional_header['SizeOfStackReserve'] = [np.NaN]
        try:
            optional_header['SizeOfStackCommit'] = [pe_file.OPTIONAL_HEADER.SizeOfStackCommit]
        except:
            optional_header['SizeOfStackCommit'] = [np.NaN]
        try:
            optional_header['SizeOfHeapReserve'] = [pe_file.OPTIONAL_HEADER.SizeOfHeapReserve]
        except:
            optional_header['SizeOfHeapReserve'] = [np.NaN]
        try:
            optional_header['SizeOfHeapCommit'] = [pe_file.OPTIONAL_HEADER.SizeOfHeapCommit]
        except:
            optional_header['SizeOfHeapCommit'] = [np.NaN]
        try:
            optional_header['LoaderFlags'] = [pe_file.OPTIONAL_HEADER.LoaderFlags]
        except:
            optional_header['LoaderFlags'] = [np.NaN]
        try:
            optional_header['NumberOfRvaAndSizes'] = [pe_file.OPTIONAL_HEADER.NumberOfRvaAndSizes]
        except:
            optional_header['NumberOfRvaAndSizes'] = [np.NaN]
        return optional_header

    def get_all_pe_information(self, pe_file_path):
        # Load the PE file
        pe_file = PE(pe_file_path)
        # Create a dictionary to store all headers of the PE file
        pe_info = dict()
        # Extract all information about PE file
        pe_info.update(self.get_dos_header(pe_file))
        pe_info.update({'Signature': [self.get_signature(pe_file)]})
        pe_info.update(self.get_file_header(pe_file))
        pe_info.update(self.get_optional_header(pe_file))
        return pe_info


class BenignExplorer(SampleExplorer):
    def __init__(self):
        super().__init__()
        self.inner_raw_benign = 'data/raw/benign'
        self._raw_benign_directory = ''
        self.benign_data = pd.DataFrame()

    @property
    def raw_benign_directory(self):
        return self._raw_benign_directory

    @raw_benign_directory.setter
    def raw_benign_directory(self, new_raw_directory):
        self._raw_benign_directory = new_raw_directory

    def set_raw_benign_directory(self):
        self.raw_benign_directory = get_project_root_directory()/Path(self.inner_raw_benign)

    def benign_labelling(self, pe_info: dict):
        label = {'Class': 'benign'}
        pe_info.update(label)

    def get_all_benign_data(self):
        # Set raw benign directory, as well as csv location
        self.set_raw_benign_directory()
        self.set_csv_location()
        # Get all benign sample paths
        all_benign_paths = list(self.raw_benign_directory.glob('**/*'))[20:]
        file_index = 0
        num_of_files = len(all_benign_paths)
        for file_path in all_benign_paths:
            # Retrieve all PE data of the sample, then label it
            pe_info = self.get_all_pe_information(file_path)
            self.benign_labelling(pe_info)
            # Convert the labelled information into a Pandas Dataframe
            sample_dataframe = pd.DataFrame.from_dict(pe_info)
            # Add the sample dataframe to the main benign dataframe
            self.benign_data = self.benign_data.append(sample_dataframe, ignore_index=True)
            file_index += 1
            os.system('clear')
            print('Benign scan progress: {0}/{1}'.format(file_index, num_of_files))

    def export_to_csv(self):
        # Write the main dataframe to the csv
        self.benign_data.to_csv(self.csv_location, mode='w', index=False)


class MalwareExplorer(SampleExplorer):
    def __init__(self):
        super().__init__()
        self.inner_raw_malware = 'data/raw/malware'
        self._raw_malware_directory = ''
        self.malware_data = pd.DataFrame()

    @property
    def raw_malware_directory(self):
        return self._raw_malware_directory

    @raw_malware_directory.setter
    def raw_malware_directory(self, updated_malware_directory):
        self._raw_malware_directory = updated_malware_directory

    def set_raw_malware_directory(self):
        self.raw_malware_directory = get_project_root_directory() / Path(self.inner_raw_malware)

    def malware_labelling(self, pe_info: dict):
        label = {'Class': 'malware'}
        pe_info.update(label)

    def get_all_malware_data(self):
        # Set raw malware directory, as well as csv location
        self.set_raw_malware_directory()
        self.set_csv_location()
        # Get all malware sample paths
        all_malware_paths = list(self.raw_malware_directory.glob('*'))
        file_index = 0
        num_of_files = len(all_malware_paths)
        for file_path in all_malware_paths:
            # Retrieve all PE data of the sample, then label it
            pe_info = self.get_all_pe_information(file_path)
            self.malware_labelling(pe_info)
            # Convert the labelled information into a Pandas Dataframe
            sample_dataframe = pd.DataFrame.from_dict(pe_info)
            # Add the sample to the main dataframe
            self.malware_data = self.malware_data.append(sample_dataframe, ignore_index=True)
            file_index += 1
            os.system('clear')
            print('Malware scan progress: {0}/{1}'.format(file_index, num_of_files))

    def export_to_csv(self):
        # Append the dataframe to the csv
        self.malware_data.to_csv(self.csv_location, mode='a', index=False, header=False)
